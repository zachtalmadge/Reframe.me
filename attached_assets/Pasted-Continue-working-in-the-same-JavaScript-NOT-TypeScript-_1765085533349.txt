Continue working in the same JavaScript (NOT TypeScript) + React + Tailwind CSS, mobile-first project.
The Home page hero currently has a single “before / after” text pair that fades in, something like:

A “Before” phrase (e.g., how it feels to disclose now).

An “After” phrase (e.g., how it can feel after using Reframe.me).

The existing behavior:

The “before” line fades in first, and then the “after” line fades in shortly after.

This creates a gentle, trauma-aware “transformation” moment.

I now want to add 3 more before/after pairs (for a total of 4 pairs), and have them rotate automatically:

The hero should cycle through all 4 before/after pairs.

Every 4 seconds, we move to the next pair.

For each pair, the before text still fades in first, then the after text fades in, just like the existing animation.

Important for this change:
For this change, DO NOT perform any end-to-end (e2e) tests or automated full-flow testing.
You may perform local/component-level checks only. I will manually confirm the change in the UI.

Business requirement – Hero rotates 4 before/after pairs, same staggered fade

Update the Home hero “before / after” text area so that:

Instead of only one pair, the hero now has 4 distinct before/after pairs (the existing one plus 3 new pairs).

The content should be defined in a data structure (e.g., an array of objects) like:

const beforeAfterPairs = [
  { before: "...", after: "..." },
  { before: "...", after: "..." },
  { before: "...", after: "..." },
  { before: "...", after: "..." },
];


(You can keep the exact strings as placeholders or insert copy we already use; I’ll edit the text later if needed.)

Rotation behavior:

Every 4 seconds, the component should move to the next before/after pair in the array.

When we reach the last pair, the next step wraps back to the first pair (continuous loop).

Animation behavior for each pair:

For the currently active pair:

The “before” line fades in first.

Shortly after, the “after” line fades in, just like the current hero behavior.

The fade-in timing and transition style should be:

Consistent with the current implementation (e.g., the same Tailwind transition / duration / opacity classes).

Soft and non-jarring (no harsh popping in/out).

Accessibility & motion:

Respect any existing prefers-reduced-motion patterns (e.g., using motion-safe: or disabling the auto-rotation if motion should be reduced).

Text should never be unreadable or flashing.

This change should only affect the hero before/after text logic and its associated animation state, not other sections.

Acceptance criteria (Given / When / Then)
Scenario: Hero cycles through 4 before/after pairs

Given the user lands on the Home page and watches the hero

When enough time passes

Then:

They see a sequence of 4 different before/after pairs, one pair at a time.

Each pair stays visible long enough to read before the next pair appears.

Scenario: Rotation timing (4 seconds per pair)

Given the hero has 4 before/after pairs

When the hero is animating normally

Then:

Approximately every 4 seconds, the active pair changes to the next pair.

After the 4th pair, the sequence wraps to the 1st pair and continues.

Scenario: “Before” always fades in before “After”

Given any one of the pairs becomes active

When the animation plays for that pair

Then:

The “before” text appears/fades in first.

Then, after a short delay, the “after” text fades in, matching the current hero’s animation style.

This staggered fade is consistent across all 4 pairs.

Scenario: No harsh jumps during rotation

Given the hero is rotating through pairs automatically

When it transitions from one pair to the next

Then:

There are no harsh jumps between pairs (no text instantly snapping between phrases).

Any fade-out / fade-in for pair transitions is soft, consistent with the app’s trauma-aware tone.

Scenario: Motion remains comfortable and accessible

Given the user has motion-reduction settings enabled (if the app already supports this)

When they view the hero

Then:

The animation respects prefers-reduced-motion patterns used elsewhere (e.g., reduced or no auto-rotation), if applicable.

There is no rapid flashing or disorienting movement.

Scenario: No regressions to hero layout or content outside the rotating area

Given the hero structure (headline, subheading, CTA, etc.) before this change

When the before/after rotation behavior is added

Then:

The rest of the hero (headline, description, button) remains unchanged in layout and content.

Only the rotating before/after area has changed.

What I want you (Replit AI) to do

Assess the current hero before/after implementation

Locate the Home page hero component where the current before/after pair is rendered.

Identify:

How the current fade-in animation is implemented (Tailwind classes, conditional rendering, CSS transitions, etc.).

How timing is currently handled (e.g., setTimeout, setInterval, useEffect, local state like showBefore, showAfter).

Describe your understanding of the requirements

In your own words, explain:

That you will introduce a data-driven array of before/after pairs (4 total).

That you will add logic to rotate through these pairs every 4 seconds.

That for each pair, the before text fades in first, then the after text, reusing the existing fade pattern.

That you will keep animation soft and respect existing motion preferences (e.g., motion-safe:).

Identify key considerations to avoid disrupting existing functionality

Ensure that:

Timer logic (e.g., setInterval / setTimeout) is properly cleaned up in useEffect (clear interval on unmount) to avoid memory leaks.

State updates for the active index and before/after visibility do not cause unnecessary re-renders or glitches.

The hero still renders correctly on first load:

The initial pair appears cleanly.

There’s no flicker of undefined/empty text.

Adding more pairs doesn’t break layout (e.g., text wraps gracefully).

Propose best-practice implementation details

Describe a likely implementation pattern, such as:

Define an array of 4 before/after pairs at the top of the hero file.

Use const [currentIndex, setCurrentIndex] = useState(0);

Use additional state like showBefore, showAfter (or a small state machine) to manage staggered fade-ins per pair.

Use useEffect with setInterval of 4 seconds to advance currentIndex and reset showBefore/showAfter appropriately.

Explain how to align with existing animation classes, e.g.:

opacity-0 → opacity-100 with transition-opacity, duration-500 or similar.

Use classes like group, group-[state], or conditionals to toggle fade-in.

Assess other best practices

Motion / accessibility:

Use motion-safe: prefixes for animations if the project already does so.

Performance:

Keep interval logic simple and scoped to the hero component.

Code clarity:

Keep the rotation logic readable and easily adjustable (e.g., a single ROTATION_INTERVAL_MS = 4000 constant).

Generate a step-by-step plan to implement this enhancement

At a minimum include:

Step 1: Define an array of 4 before/after pairs in the hero component (reusing the existing pair plus 3 new ones).

Step 2: Introduce state for:

currentIndex (0–3) for which pair is active.

Any flags needed to control before vs after visibility (e.g., showBefore, showAfter).

Step 3: Use useEffect to:

Trigger the staggered appearance of before then after for the active pair.

Set up an interval that:

Runs every 4000 ms.

Advances currentIndex (with wrap-around to 0).

Resets showBefore/showAfter for the new pair.

Clean up the interval on unmount.

Step 4: Update the hero JSX to:

Render the beforeAfterPairs[currentIndex].before and .after.

Apply Tailwind classes that:

Start the text as opacity-0 and transition to opacity-100 when showBefore / showAfter are true.

Step 5: Manually verify:

The hero cycles through all 4 pairs.

Each pair shows “before” first, then “after”.

Rotation timing is about 4 seconds per pair.

Layout is intact on mobile and desktop.

Step 6: Confirm there are no console warnings or interval leaks.

Keep the scope limited

Do not:

Change the hero’s main headline, subheading, or CTA buttons.

Modify unrelated animations (How It Works, Safe-space section, Stories of Change, etc.).

Alter global timing for other animations.

Only:

Update the hero’s before/after text rotation and its immediate animation state.

Propose a skeleton framework

Provide a simplified skeleton (in JavaScript React, not TypeScript) to illustrate the approach, for example:

const ROTATION_INTERVAL_MS = 4000;

const beforeAfterPairs = [
  { before: "Before: I freeze when they ask about my record.", after: "After: I have a clear, honest way to answer." },
  { before: "Before: I avoid applying because of my past.", after: "After: I can explain my growth and skills." },
  { before: "Before: I’m not sure what to say in a pre-adverse letter.", after: "After: I have a structured response in my own voice." },
  { before: "Before: I feel alone figuring this out.", after: "After: I have talking points I can share with someone I trust." },
];

function Hero() {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [showBefore, setShowBefore] = useState(false);
  const [showAfter, setShowAfter] = useState(false);

  useEffect(() => {
    // Staggered fade for current pair
    setShowBefore(false);
    setShowAfter(false);

    const beforeTimeout = setTimeout(() => setShowBefore(true), 200); // small delay
    const afterTimeout = setTimeout(() => setShowAfter(true), 900);   // after before

    return () => {
      clearTimeout(beforeTimeout);
      clearTimeout(afterTimeout);
    };
  }, [currentIndex]);

  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentIndex((prev) => (prev + 1) % beforeAfterPairs.length);
    }, ROTATION_INTERVAL_MS);

    return () => clearInterval(interval);
  }, []);

  const pair = beforeAfterPairs[currentIndex];

  return (
    <section className="...">
      {/* ...hero heading, subheading, CTA... */}

      <div className="mt-6 space-y-2 text-sm text-slate-100">
        <p
          className={`transition-opacity duration-500 ${
            showBefore ? "opacity-100" : "opacity-0"
          }`}
        >
          {pair.before}
        </p>
        <p
          className={`transition-opacity duration-500 ${
            showAfter ? "opacity-100" : "opacity-0"
          }`}
        >
          {pair.after}
        </p>
      </div>
    </section>
  );
}


You should adapt class names, timing, and copy to match the existing hero implementation and design system.

Do not modify any files yet

First, output your understanding of this hero rotation enhancement and your implementation plan.

Remember: do NOT perform any e2e tests for this change—I will manually confirm behavior.

Wait for my confirmation that your approach is sound before updating the code.